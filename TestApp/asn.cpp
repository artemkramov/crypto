#include "asn.h"
#include "Wincrypt.h"
#include <stdio.h>
#include <fstream>
#include <iostream>
#include <vector>
#include <tchar.h>
#pragma comment(lib, "crypt32.lib")

#define CERT_TYPE X509_ASN_ENCODING

using namespace std;

BYTE pbEncoded1[] = {0x30 , 0x82 , 0x02 , 0x77 , 0x02 , 0x01 , 0x00 , 0x30 , 0x0D , 0x06 , 0x09 , 0x2A , 0x86 , 0x48 , 0x86 , 0xF7 , 0x0D , 0x01 , 0x01 , 0x01 , 0x05 , 0x00 , 0x04 , 0x82 , 0x02 , 0x61 , 0x30 , 0x82 , 0x02 , 0x5D , 0x02 , 0x01 , 0x00 , 0x02 , 0x81 , 0x81 , 0x00 , 0xBE , 0xFF , 0xE5 , 0x3D , 0xF5 , 0x81 , 0xFD , 0x35 , 0xDB , 0xAD , 0xF4 , 0xDB , 0x50 , 0x86 , 0x80 , 0xE7 , 0x6C , 0xC9 , 0xC5 , 0x47 , 0x1E , 0xB1 , 0x6C , 0x7F , 0xE8 , 0xB7 , 0x50 , 0x36 , 0xA5 , 0x4E , 0xE6 , 0x34 , 0xDC , 0x69 , 0xDF , 0xC1 , 0x6B , 0xCD , 0xBB , 0x07 , 0x09 , 0xAA , 0x49 , 0x86 , 0xA8 , 0x03 , 0xB8 , 0xDC , 0x07 , 0xAD , 0x15 , 0x08 , 0x0A , 0x26 , 0xD1 , 0x81 , 0x98 , 0x61 , 0x77 , 0xAF , 0xAA , 0xFE , 0x5B , 0x74 , 0xBB , 0x4B , 0xA4 , 0x75 , 0x84 , 0xF6 , 0xA6 , 0xA7 , 0xFD , 0x0D , 0xD8 , 0x49 , 0xE6 , 0x7D , 0x92 , 0x85 , 0x69 , 0x46 , 0x70 , 0x9B , 0x75 , 0x73 , 0x0B , 0x05 , 0xAC , 0x2F , 0x6F , 0x97 , 0x2C , 0xC9 , 0x9F , 0x52 , 0xC5 , 0x9F , 0x7C , 0xAB , 0x7A , 0x9D , 0xD3 , 0x97 , 0xD2 , 0xE3 , 0xE9 , 0xD6 , 0xFD , 0xA6 , 0x46 , 0xCB , 0xA0 , 0x2F , 0x0B , 0x33 , 0x24 , 0x9B , 0x7A , 0xC3 , 0xB3 , 0xFA , 0x89 , 0xD1 , 0x20 , 0x52 , 0xB3 , 0xE9 , 0x02 , 0x03 , 0x01 , 0x00 , 0x01 , 0x02 , 0x81 , 0x80 , 0x6C , 0xC8 , 0x35 , 0xFA , 0x59 , 0xEF , 0xD5 , 0x15 , 0x6D , 0xAE , 0xDF , 0xFC , 0x61 , 0x1A , 0x9A , 0x24 , 0x34 , 0xB3 , 0x9E , 0x66 , 0x69 , 0x36 , 0xC8 , 0x02 , 0xF9 , 0xBA , 0x1E , 0x37 , 0x61 , 0x63 , 0x54 , 0x7D , 0xDA , 0xE3 , 0x7A , 0x0B , 0x21 , 0xA9 , 0x24 , 0xD2 , 0x57 , 0x50 , 0xE3 , 0x5B , 0x8C , 0x29 , 0xC2 , 0x89 , 0x9E , 0xDD , 0x97 , 0x52 , 0xE2 , 0xE5 , 0x45 , 0x01 , 0xB8 , 0x96 , 0x1A , 0xA2 , 0xB4 , 0x92 , 0xF5 , 0xE6 , 0xC1 , 0xF4 , 0x96 , 0x6C , 0x26 , 0xCF , 0x05 , 0x58 , 0xB0 , 0xCF , 0x5C , 0xA7 , 0xCD , 0x5D , 0xE6 , 0xD0 , 0x60 , 0x1F , 0xEB , 0x8C , 0x71 , 0xB9 , 0xF9 , 0x1A , 0xE6 , 0xC5 , 0xD9 , 0xAC , 0x17 , 0x10 , 0x87 , 0xE3 , 0x84 , 0x5E , 0xC6 , 0x2F , 0xC4 , 0x98 , 0xB5 , 0xB1 , 0xD3 , 0x9C , 0x29 , 0x8C , 0xEB , 0x9D , 0x0C , 0x61 , 0x32 , 0x60 , 0x72 , 0xBF , 0xCF , 0x1D , 0xC3 , 0x17 , 0xD7 , 0x62 , 0xED , 0xBA , 0x24 , 0x9B , 0x7C , 0x61 , 0x02 , 0x41 , 0x00 , 0xFC , 0xEF , 0x68 , 0xAC , 0xB7 , 0x64 , 0x43 , 0xF6 , 0x91 , 0x74 , 0xC2 , 0x73 , 0xFC , 0xA6 , 0x0F , 0x15 , 0xA3 , 0x10 , 0x57 , 0xD8 , 0x30 , 0x09 , 0xA1 , 0xE1 , 0x44 , 0x11 , 0x09 , 0x0B , 0x3A , 0x17 , 0xC5 , 0x6C , 0xE1 , 0x25 , 0x32 , 0xD4 , 0x52 , 0xEA , 0x5F , 0x20 , 0xEC , 0x73 , 0x38 , 0xEC , 0x49 , 0xF2 , 0x9F , 0x38 , 0x56 , 0x80 , 0xB3 , 0x6A , 0x04 , 0xA0 , 0x5B , 0xF8 , 0xBE , 0xDD , 0x78 , 0x91 , 0xA1 , 0xC0 , 0xD6 , 0x45 , 0x02 , 0x41 , 0x00 , 0xC1 , 0x50 , 0x5D , 0xA2 , 0x00 , 0xC1 , 0x6B , 0x83 , 0xD9 , 0xF6 , 0xE6 , 0x3E , 0x50 , 0x2F , 0xAF , 0x57 , 0xBF , 0xD8 , 0x38 , 0x4F , 0x30 , 0x76 , 0x8B , 0xBE , 0x81 , 0x0D , 0x12 , 0xAE , 0x74 , 0x73 , 0xFE , 0xA8 , 0xC1 , 0x0E , 0xF6 , 0x85 , 0x11 , 0x3A , 0xB3 , 0xCE , 0x48 , 0x37 , 0x04 , 0x56 , 0x07 , 0x83 , 0x42 , 0xD9 , 0x91 , 0x84 , 0xEF , 0xF5 , 0xC6 , 0x4D , 0x61 , 0x2C , 0x07 , 0x7D , 0x30 , 0x36 , 0xAF , 0x91 , 0xC3 , 0x55 , 0x02 , 0x41 , 0x00 , 0x99 , 0xB8 , 0x8E , 0xEF , 0x59 , 0x4D , 0xD0 , 0x98 , 0x4B , 0xF2 , 0xA0 , 0x33 , 0x89 , 0xBB , 0x0A , 0xB3 , 0xE5 , 0xB4 , 0x8B , 0x0E , 0xD2 , 0xB3 , 0x27 , 0xF5 , 0x16 , 0x3F , 0x1C , 0x35 , 0xFC , 0x8A , 0x71 , 0xEC , 0x28 , 0x31 , 0x49 , 0x61 , 0x0D , 0x3B , 0x6F , 0xB1 , 0x3C , 0xC3 , 0x12 , 0x37 , 0x59 , 0x01 , 0xE1 , 0x8E , 0x85 , 0xD4 , 0x16 , 0x36 , 0x3A , 0xB5 , 0x92 , 0xEF , 0xEC , 0x60 , 0x01 , 0x64 , 0xD0 , 0xDF , 0xB7 , 0xD9 , 0x02 , 0x40 , 0x72 , 0xAC , 0xD6 , 0xEE , 0x8C , 0x5E , 0x31 , 0x06 , 0x65 , 0x5D , 0x66 , 0x96 , 0x1E , 0x81 , 0x3B , 0x15 , 0xE5 , 0xD3 , 0x41 , 0x0C , 0x10 , 0xE6 , 0xB1 , 0xDD , 0x4F , 0xB6 , 0xCE , 0x97 , 0x38 , 0xB3 , 0xBA , 0xA4 , 0xA6 , 0xE9 , 0xD6 , 0x69 , 0x77 , 0xA0 , 0x08 , 0x1B , 0xDD , 0x90 , 0xED , 0x7C , 0x8F , 0x36 , 0x59 , 0x88 , 0xB1 , 0x1F , 0x58 , 0x2D , 0xC6 , 0xF6 , 0x0E , 0x27 , 0xCD , 0x45 , 0x81 , 0x3D , 0x5F , 0x87 , 0x2B , 0x85 , 0x02 , 0x41 , 0x00 , 0xC8 , 0x1C , 0xD5 , 0x83 , 0xB9 , 0xE6 , 0xB0 , 0xDD , 0x78 , 0x14 , 0x56 , 0x94 , 0x7F , 0x82 , 0x68 , 0x12 , 0xEC , 0xDD , 0x2D , 0x38 , 0x2E , 0x39 , 0x4B , 0xD6 , 0x54 , 0x36 , 0x0C , 0xA5 , 0xB6 , 0x11 , 0x48 , 0x5D , 0xF4 , 0xBD , 0x57 , 0xEA , 0xE9 , 0xDD , 0x93 , 0x43 , 0x48 , 0x96 , 0x51 , 0x2E , 0xA2 , 0xE9 , 0x3B , 0x8A , 0xF7 , 0xE2 , 0x9D , 0xD3 , 0x18 , 0xAB , 0xBA , 0x07 , 0xD2 , 0xC5 , 0xA3 , 0x21 , 0x55 , 0x4F , 0xE5 , 0xCF};

BYTE* pbEncoded;

BOOL CALLBACK MyResolve(CRYPT_PRIVATE_KEY_INFO      *pPrivateKeyInfo,
                        HCRYPTPROV                  *phCryptProv,
                        LPVOID                      pVoidResolveFunc)
{
   BOOL bStatus = FALSE;
   printf("phCryptProv = 0x%.8X\n", phCryptProv);
   printf("Private Key Algorithm = %s\n", pPrivateKeyInfo->Algorithm.pszObjId);

   if (phCryptProv)
   {
      bStatus = CryptAcquireContext(phCryptProv, _T("test"), NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET);
      if (!bStatus)
      {
         CryptAcquireContext(phCryptProv, _T("test"), NULL, PROV_RSA_FULL, CRYPT_DELETEKEYSET);
         bStatus = CryptAcquireContext(phCryptProv, _T("test"), NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET);
      }
   }

   return bStatus;
}

BOOL CALLBACK MyDecrypt(
      CRYPT_ALGORITHM_IDENTIFIER Algorithm,
      CRYPT_DATA_BLOB EncryptedPrivateKey,
      BYTE* pbClearTextKey,
      DWORD* pcbClearTextKey,
      LPVOID pVoidDecryptFunc)
{
   printf("Algorithm used for encryption : %s\n\n", Algorithm.pszObjId);
   if (pbClearTextKey && *pcbClearTextKey >= sizeof(pbEncoded))
   {
      memcpy(pbClearTextKey, pbEncoded, sizeof(pbEncoded));
      *pcbClearTextKey = sizeof(pbEncoded);
   }
   else
      *pcbClearTextKey = sizeof(pbEncoded);

   return TRUE;
}


void ASNDecode()
{
	char* name = "E:/key.p8";
	FILE *fl = fopen(name, "rb");  
    fseek(fl, 0, SEEK_END);  
    long len = ftell(fl);  
	char *ret = (char*)malloc(len * sizeof(char));  
    fseek(fl, 0, SEEK_SET);  
    fread(ret, len, 1, fl);  
    fclose(fl);
	

	DWORD cbEncoded = len;        // variable to hold the
                                  // length of the encoded string
	DWORD cbDecoded;              // variable to hold the 
                                  // length of the decoded buffer

	pbEncoded = (BYTE*)ret; // variable to hold a pointer to the 
								  // encoded buffer
	/*for (int i = 0; i < len; i++)
	{
		printf("%02x\n", pbEncoded[i]);
	}*/
	BYTE *pbDecoded;              // variable to hold a pointer to the
                                  // decoded buffer
	/*CRYPT_DIGEST_BLOB keyBlob;
	   CRYPT_PKCS8_IMPORT_PARAMS param;

	   keyBlob.cbData = len;
	   keyBlob.pbData = pbEncoded;
	   ZeroMemory(&param, sizeof(param));
	   param.pDecryptPrivateKeyFunc = MyDecrypt;
	   param.pResolvehCryptProvFunc = MyResolve;
	   param.PrivateKey = keyBlob;

	   BOOL bStatus = CryptImportPKCS8(param, 0, NULL, NULL);
	   if (bStatus)
	   {
		  printf("CryptImportPKCS8 success!\n");
	   }
	   else
	   {
		  printf("CryptImportPKCS8 Error 0x%.8X.\n", GetLastError());
	   }*/

	//if(CryptDecodeObjectEx(
	//	CRYPT_ASN_ENCODING,
	//	PKCS_PRIVATE_KEY_INFO,
	//	pbEncoded,                // the buffer to be decoded
	//	cbEncoded,
	//	0,
	//	NULL, 
	//	NULL,
	//	&cbDecoded))
	//{
	//	printf("The needed buffer length is %d\n", cbDecoded);
	//	pbDecoded = (BYTE*)malloc(cbDecoded * sizeof(BYTE));
	//	if(CryptDecodeObjectEx(
	//		CRYPT_ASN_ENCODING,
	//		PKCS_PRIVATE_KEY_INFO,
	//		pbEncoded,                // the buffer to be decoded
	//		cbEncoded,
	//		CRYPT_DECODE_ALLOC_FLAG,
	//		NULL, 
	//		pbDecoded,
	//		&cbDecoded))
	//	{
	//		CRYPT_PRIVATE_KEY_INFO *pDecodeName = (CRYPT_PRIVATE_KEY_INFO*)pbDecoded;
	//		DWORD cAttr = pDecodeName->pAttributes->cAttr;
	//		printf("Parsed!!! \n");
	//	}
	//	else
	//	{
	//		printf("Decoding failed 2 \n");
	//	}

	//}
	//else
	//{
	//	printf("Decoding failed 1 \n");
	//	int a = 3;
	//}
}